/*
给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。

请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。

你可以假设 nums1 和 nums2 不会同时为空。

 

示例 1:

nums1 = [1, 3]
nums2 = [2]

则中位数是 2.0
示例 2:

nums1 = [1, 2]
nums2 = [3, 4]

则中位数是 (2 + 3)/2 = 2.5

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/median-of-two-sorted-arrays
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
*/

class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        int TotalLength = nums1.size() + nums2.size();
        int Asize = nums1.size();
        int Bsize = nums2.size();
        if(TotalLength & 0x01 ) //奇数情况
        {
            return find_k_th(nums1.begin(), Asize, nums2.begin(), Bsize, TotalLength/2 + 1);
        }
        else // 偶数情况
        {
            return (find_k_th(nums1.begin(), Asize, nums2.begin(), Bsize, TotalLength/2) + find_k_th(nums1.begin(), Asize, nums2.begin(), Bsize, TotalLength/2 + 1)) / 2.0;
        }
    }

    static int find_k_th(std::vector<int>::const_iterator nums1, int Asize, std::vector<int>::const_iterator nums2, int Bsize, int k)
    {
        //判断终止和倒换迭代条件
        if(Asize > Bsize)  //默认A更小一点 否则反过来操作
        {
            return find_k_th(nums2, Bsize, nums1, Asize, k);
        }
        if(0 == Asize)  //如果A的大小为0了，则返回B的第K个数即可，而第K个数的索引即为 k-1
        {
            return *(nums2 + k - 1);
        }
        if(1 == k) //如果 k = 1， 则返回A和B的索引目前的值中较小的一个即可
        {
            return min(*(nums1),*(nums2));
        }

        //如果都不满足，则K是一个>= 2的数，且Asize Bsize都不为0， 且A不为空
        //假设A序列和B序列分别需要去掉的长度为ia、ib,则 k = ia + ib;
        //ia = min(Asize,k/2);
        //理解 假设k = 7 ,则 k/2 = 3, 假设A Bsize远远大于这个数， 则ia = 3 , ib = 4， 需要比较 A的第三个数与B的第四个数之间的大小
        //如果A的大一些，那么B的前ib个数都能丢掉，反之A的前ia个数能丢掉
        int ia = min(Asize,k/2);
        int ib = k - ia;
        
        if(*(nums1 + ia - 1) > *(nums2 + ib - 1))
        {
            return find_k_th(nums1 , Asize, nums2 + ib, Bsize - ib, k - ib);
        }
        else if (*(nums1 + ia - 1) < *(nums2 + ib - 1))
        {
            return find_k_th(nums1 + ia, Asize - ia, nums2, Bsize, k - ia);
        }
        else //如果 两个数相等
        {
            return *(nums2 + ib - 1);
        }
    }
};
